---
title: 查找
date: 2024-10-24
tags:
- 算法
- 查找算法
categories: 算法
---

# 线性表的查找

**数据类型**

```c
typedef struct {
    KeyType key; // 关键字域
    InfoType otherinfo; // 其他域
}ElemType;

typedef struct {
    ElemType *R; // 存储空间基地址
    int length;  // 当前长度
}SSTable;

```

## 顺序查找

> 从表的一端开始，依次将记录的关键字和给定值进行比价，若某个记录的关键字和给定值相等，则查找成功；反之，若扫描整个表后，仍为找到关键字和给定值相等的记录，则查找失败。时间复杂度`O(n)`

```c
// 此假设元素从st.R[1]开始顺序向后存放，st.R[0]闲置不用，查找时从表的最后开始比较
int Search_Seq(SSTable st, KeyType key)
{
    for (int i = st.length; i >= 1; i--)
    {
        if (st.R[i].key == key)
        {
            return i;
        }
    }
    return 0;
}

// 对st.R[0]的关键字赋值key，在此，st.R[0]起到了监视哨的作用
int Search_Seq2(SSTable st, KeyType key)
{
    st.R[0].key = key;
	int i = st.length;
    for (; st.R[i].key != key; i--);
    return i;
}
```

## 折半查找

> 折半查找也称为二分查找，拆半查找要求线性表必须采用顺序存储结构，而且表中元素按关键字有序排列。时间复杂度$O(log_2n)$

```c
// 在有序表st中折半查找其关键字等于key的数据元素。若找到，则函数值为该元素在表中的位置，否则为0
// 有序表st默认递增排序
int Search_Bin(SSTable st, KeyType key)
{
    int low = 1;
    int higt = st.length;
    while (low < higt)
    {
        int mid = (low + higt) / 2;
        if (key == st.R[mid].key)
        {
            return mid;
        } else if (key < st.R[mid].key)
        {
            higt = mid - 1;
        } else
        {
            low = mid + 1;
        }
    }
    return 0;
}
```

## 分块查找

> 分块查找又称索引顺序查找。在该查找方法中，除表本身以外，尚需建立一个“索引表”。时间复杂度$O(\sqrt n)$

**步骤**

1.  **分块**：将数组分成若干个大小相同的块（最后一个块可能较小）
2.  **查找块**：通过比较目标值与每个块的起始元素，确定目标值可能所在的块
3.  **顺序查找**：在确定的块内进行顺序查找，找到目标值

```c
#include <math.h>

#define BLOCK_SIZE 3 // 定义块的大小

// 分块查找函数
int blockSearch(int arr[], int size, int target) {
    int blockCount = (int)ceil((double)size / BLOCK_SIZE); // 计算块的数量

    // 查找目标值所在的块
    for (int i = 0; i < blockCount; i++) {
        // 计算当前块的起始和结束索引
        int start = i * BLOCK_SIZE;
        int end = (i + 1) * BLOCK_SIZE < size ? (i + 1) * BLOCK_SIZE : size;

        // 如果目标值在当前块的范围内
        if (target >= arr[start] && target < arr[end - 1]) {
            // 在当前块内进行顺序查找
            for (int j = start; j < end; j++) {
                if (arr[j] == target) {
                    return j; // 找到目标值，返回索引
                }
            }
            break; // 如果在块内找到了，退出循环
        }
    }
    return -1; // 未找到目标值，返回-1
}
```

# 树表的查找

## 二叉排序树

## 平衡二叉树

## B-树

## B+树

# 散列表的查找

## 散列函数的基本概念

## 散列函数构造方法

### 数字分析法

### 平方取中法

### 折叠法

### 除留余数法

## 如何处理冲突

### 开放地址法

### 链地址法

## 散列表的查找
